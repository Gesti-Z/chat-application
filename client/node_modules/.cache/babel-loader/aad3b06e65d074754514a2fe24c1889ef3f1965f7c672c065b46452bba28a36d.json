{"ast":null,"code":"import { useMemo, useRef } from 'react';\nvar STATUSES_EXCLUDED_FROM_PREPEND = {\n  failed: true,\n  sending: true\n};\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n  var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n  var firstMessageOnFirstLoadedPage = useRef();\n  var previousFirstMessageOnFirstLoadedPage = useRef();\n  var previousNumItemsPrepended = useRef(0);\n  var numItemsPrepended = useMemo(function () {\n    var _a, _b;\n    if (!messages || !messages.length) {\n      previousNumItemsPrepended.current = 0;\n      return 0;\n    }\n    var currentFirstMessage = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex];\n    var noNewMessages = (currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.id) === ((_a = previousFirstMessageOnFirstLoadedPage.current) === null || _a === void 0 ? void 0 : _a.id);\n    // This is possible only, when sending messages very quickly (basically single char messages submitted like a crazy) in empty channel (first page)\n    // Optimistic UI update, when sending messages, can lead to a situation, when\n    // the order of the messages changes for a moment. This can happen, when a user\n    // sends multiple messages withing few milliseconds. E.g. we send a message A\n    // then message B. At first we have message array with both messages of status \"sending\"\n    // then response for message A is received with a new - later - created_at timestamp\n    // this leads to rearrangement of 1.B (\"sending\"), 2.A (\"received\"). Still firstMessageOnFirstLoadedPage.current\n    // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1\n    // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message\n    // at non-existent index. Therefore, we ignore messages of status \"sending\" / \"failed\" in order they are\n    // not considered as prepended messages.\n    var firstMsgMovedAfterMessagesInExcludedStatus = !!((currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.status) && STATUSES_EXCLUDED_FROM_PREPEND[currentFirstMessage.status]);\n    if (noNewMessages || firstMsgMovedAfterMessagesInExcludedStatus) {\n      return previousNumItemsPrepended.current;\n    }\n    if (!firstMessageOnFirstLoadedPage.current) {\n      firstMessageOnFirstLoadedPage.current = currentFirstMessage;\n    }\n    previousFirstMessageOnFirstLoadedPage.current = currentFirstMessage;\n    // if new messages were prepended, find out how many\n    // start with this number because there cannot be fewer prepended items than before\n    for (var prependedMessageCount = previousNumItemsPrepended.current; prependedMessageCount < messages.length; prependedMessageCount += 1) {\n      var messageIsFirstOnFirstLoadedPage = messages[prependedMessageCount].id === ((_b = firstMessageOnFirstLoadedPage.current) === null || _b === void 0 ? void 0 : _b.id);\n      if (messageIsFirstOnFirstLoadedPage) {\n        previousNumItemsPrepended.current = prependedMessageCount - firstRealMessageIndex;\n        return previousNumItemsPrepended.current;\n      }\n    }\n    // if no match has found, we have jumped - reset the prepended item count.\n    firstMessageOnFirstLoadedPage.current = currentFirstMessage;\n    previousNumItemsPrepended.current = 0;\n    return 0;\n    // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n    // that's why the second dependency is necessary\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [firstRealMessageIndex, messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n  return numItemsPrepended;\n}","map":{"version":3,"names":["useMemo","useRef","STATUSES_EXCLUDED_FROM_PREPEND","failed","sending","usePrependedMessagesCount","messages","hasDateSeparator","firstRealMessageIndex","firstMessageOnFirstLoadedPage","previousFirstMessageOnFirstLoadedPage","previousNumItemsPrepended","numItemsPrepended","_a","_b","length","current","currentFirstMessage","noNewMessages","id","firstMsgMovedAfterMessagesInExcludedStatus","status","prependedMessageCount","messageIsFirstOnFirstLoadedPage"],"sources":["C:/Users/Gesti/Desktop/chat_application/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/VirtualizedMessageList/usePrependMessagesCount.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nvar STATUSES_EXCLUDED_FROM_PREPEND = {\n    failed: true,\n    sending: true,\n};\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n    var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n    var firstMessageOnFirstLoadedPage = useRef();\n    var previousFirstMessageOnFirstLoadedPage = useRef();\n    var previousNumItemsPrepended = useRef(0);\n    var numItemsPrepended = useMemo(function () {\n        var _a, _b;\n        if (!messages || !messages.length) {\n            previousNumItemsPrepended.current = 0;\n            return 0;\n        }\n        var currentFirstMessage = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex];\n        var noNewMessages = (currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.id) === ((_a = previousFirstMessageOnFirstLoadedPage.current) === null || _a === void 0 ? void 0 : _a.id);\n        // This is possible only, when sending messages very quickly (basically single char messages submitted like a crazy) in empty channel (first page)\n        // Optimistic UI update, when sending messages, can lead to a situation, when\n        // the order of the messages changes for a moment. This can happen, when a user\n        // sends multiple messages withing few milliseconds. E.g. we send a message A\n        // then message B. At first we have message array with both messages of status \"sending\"\n        // then response for message A is received with a new - later - created_at timestamp\n        // this leads to rearrangement of 1.B (\"sending\"), 2.A (\"received\"). Still firstMessageOnFirstLoadedPage.current\n        // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1\n        // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message\n        // at non-existent index. Therefore, we ignore messages of status \"sending\" / \"failed\" in order they are\n        // not considered as prepended messages.\n        var firstMsgMovedAfterMessagesInExcludedStatus = !!((currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.status) && STATUSES_EXCLUDED_FROM_PREPEND[currentFirstMessage.status]);\n        if (noNewMessages || firstMsgMovedAfterMessagesInExcludedStatus) {\n            return previousNumItemsPrepended.current;\n        }\n        if (!firstMessageOnFirstLoadedPage.current) {\n            firstMessageOnFirstLoadedPage.current = currentFirstMessage;\n        }\n        previousFirstMessageOnFirstLoadedPage.current = currentFirstMessage;\n        // if new messages were prepended, find out how many\n        // start with this number because there cannot be fewer prepended items than before\n        for (var prependedMessageCount = previousNumItemsPrepended.current; prependedMessageCount < messages.length; prependedMessageCount += 1) {\n            var messageIsFirstOnFirstLoadedPage = messages[prependedMessageCount].id === ((_b = firstMessageOnFirstLoadedPage.current) === null || _b === void 0 ? void 0 : _b.id);\n            if (messageIsFirstOnFirstLoadedPage) {\n                previousNumItemsPrepended.current = prependedMessageCount - firstRealMessageIndex;\n                return previousNumItemsPrepended.current;\n            }\n        }\n        // if no match has found, we have jumped - reset the prepended item count.\n        firstMessageOnFirstLoadedPage.current = currentFirstMessage;\n        previousNumItemsPrepended.current = 0;\n        return 0;\n        // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n        // that's why the second dependency is necessary\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [firstRealMessageIndex, messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n    return numItemsPrepended;\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,IAAIC,8BAA8B,GAAG;EACjCC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE;AACb,CAAC;AACD,OAAO,SAASC,yBAAyBA,CAACC,QAAQ,EAAEC,gBAAgB,EAAE;EAClE,IAAIC,qBAAqB,GAAGD,gBAAgB,GAAG,CAAC,GAAG,CAAC;EACpD,IAAIE,6BAA6B,GAAGR,MAAM,CAAC,CAAC;EAC5C,IAAIS,qCAAqC,GAAGT,MAAM,CAAC,CAAC;EACpD,IAAIU,yBAAyB,GAAGV,MAAM,CAAC,CAAC,CAAC;EACzC,IAAIW,iBAAiB,GAAGZ,OAAO,CAAC,YAAY;IACxC,IAAIa,EAAE,EAAEC,EAAE;IACV,IAAI,CAACR,QAAQ,IAAI,CAACA,QAAQ,CAACS,MAAM,EAAE;MAC/BJ,yBAAyB,CAACK,OAAO,GAAG,CAAC;MACrC,OAAO,CAAC;IACZ;IACA,IAAIC,mBAAmB,GAAGX,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,qBAAqB,CAAC;IAC7G,IAAIU,aAAa,GAAG,CAACD,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACE,EAAE,OAAO,CAACN,EAAE,GAAGH,qCAAqC,CAACM,OAAO,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACM,EAAE,CAAC;IAC5N;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,0CAA0C,GAAG,CAAC,EAAE,CAACH,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACI,MAAM,KAAKnB,8BAA8B,CAACe,mBAAmB,CAACI,MAAM,CAAC,CAAC;IACzN,IAAIH,aAAa,IAAIE,0CAA0C,EAAE;MAC7D,OAAOT,yBAAyB,CAACK,OAAO;IAC5C;IACA,IAAI,CAACP,6BAA6B,CAACO,OAAO,EAAE;MACxCP,6BAA6B,CAACO,OAAO,GAAGC,mBAAmB;IAC/D;IACAP,qCAAqC,CAACM,OAAO,GAAGC,mBAAmB;IACnE;IACA;IACA,KAAK,IAAIK,qBAAqB,GAAGX,yBAAyB,CAACK,OAAO,EAAEM,qBAAqB,GAAGhB,QAAQ,CAACS,MAAM,EAAEO,qBAAqB,IAAI,CAAC,EAAE;MACrI,IAAIC,+BAA+B,GAAGjB,QAAQ,CAACgB,qBAAqB,CAAC,CAACH,EAAE,MAAM,CAACL,EAAE,GAAGL,6BAA6B,CAACO,OAAO,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,EAAE,CAAC;MACtK,IAAII,+BAA+B,EAAE;QACjCZ,yBAAyB,CAACK,OAAO,GAAGM,qBAAqB,GAAGd,qBAAqB;QACjF,OAAOG,yBAAyB,CAACK,OAAO;MAC5C;IACJ;IACA;IACAP,6BAA6B,CAACO,OAAO,GAAGC,mBAAmB;IAC3DN,yBAAyB,CAACK,OAAO,GAAG,CAAC;IACrC,OAAO,CAAC;IACR;IACA;IACA;EACJ,CAAC,EAAE,CAACR,qBAAqB,EAAEF,QAAQ,EAAEA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACS,MAAM,CAAC,CAAC;EAC1G,OAAOH,iBAAiB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}