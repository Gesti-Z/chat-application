{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { useEffect, useRef } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext } from '../../../context';\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param unreadCount\n * @param wasChannelMarkedUnread\n */\nexport var useMarkRead = function (_a) {\n  var isMessageListScrolledToBottom = _a.isMessageListScrolledToBottom,\n    messageListIsThread = _a.messageListIsThread,\n    unreadCount = _a.unreadCount,\n    wasMarkedUnread = _a.wasMarkedUnread;\n  var client = useChatContext('useMarkRead').client;\n  var _b = useChannelActionContext('useMarkRead'),\n    markRead = _b.markRead,\n    setChannelUnreadUiState = _b.setChannelUnreadUiState;\n  var channel = useChannelStateContext('useMarkRead').channel;\n  var previousRenderMessageListScrolledToBottom = useRef(isMessageListScrolledToBottom);\n  useEffect(function () {\n    var shouldMarkRead = function (unreadMessages) {\n      return !document.hidden && !wasMarkedUnread && !messageListIsThread && isMessageListScrolledToBottom && unreadMessages > 0;\n    };\n    var onVisibilityChange = function () {\n      if (shouldMarkRead(channel.countUnread())) markRead();\n    };\n    var handleMessageNew = function (event) {\n      var _a, _b, _c, _d;\n      var newMessageToCurrentChannel = event.cid === channel.cid;\n      var isOwnMessage = ((_a = event.user) === null || _a === void 0 ? void 0 : _a.id) && event.user.id === ((_b = client.user) === null || _b === void 0 ? void 0 : _b.id);\n      var mainChannelUpdated = !((_c = event.message) === null || _c === void 0 ? void 0 : _c.parent_id) || ((_d = event.message) === null || _d === void 0 ? void 0 : _d.show_in_channel);\n      if (isOwnMessage) return;\n      if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n        setChannelUnreadUiState(function (prev) {\n          var _a, _b;\n          var previousUnreadCount = (_a = prev === null || prev === void 0 ? void 0 : prev.unread_messages) !== null && _a !== void 0 ? _a : 0;\n          var previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n          return __assign(__assign({}, prev || {}), {\n            last_read: (_b = prev === null || prev === void 0 ? void 0 : prev.last_read) !== null && _b !== void 0 ? _b : previousUnreadCount === 0 && (previousLastMessage === null || previousLastMessage === void 0 ? void 0 : previousLastMessage.created_at) ? new Date(previousLastMessage.created_at) : new Date(0),\n            unread_messages: previousUnreadCount + 1\n          });\n        });\n      } else if (newMessageToCurrentChannel && mainChannelUpdated && shouldMarkRead(channel.countUnread())) {\n        markRead();\n      }\n    };\n    client.on('message.new', handleMessageNew);\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    var hasScrolledToBottom = previousRenderMessageListScrolledToBottom.current !== isMessageListScrolledToBottom && isMessageListScrolledToBottom;\n    if (hasScrolledToBottom && shouldMarkRead(channel.countUnread())) markRead();\n    previousRenderMessageListScrolledToBottom.current = isMessageListScrolledToBottom;\n    return function () {\n      client.off('message.new', handleMessageNew);\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n  }, [channel, client, isMessageListScrolledToBottom, markRead, messageListIsThread, setChannelUnreadUiState, unreadCount, wasMarkedUnread]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n  if (!newMessage) return;\n  var previousLastMessage;\n  for (var i = messages.length - 1; i >= 0; i--) {\n    var msg = messages[i];\n    if (!(msg === null || msg === void 0 ? void 0 : msg.id)) break;\n    if (msg.id !== newMessage.id) {\n      previousLastMessage = msg;\n      break;\n    }\n  }\n  return previousLastMessage;\n}","map":{"version":3,"names":["__assign","useEffect","useRef","useChannelActionContext","useChannelStateContext","useChatContext","useMarkRead","_a","isMessageListScrolledToBottom","messageListIsThread","unreadCount","wasMarkedUnread","client","_b","markRead","setChannelUnreadUiState","channel","previousRenderMessageListScrolledToBottom","shouldMarkRead","unreadMessages","document","hidden","onVisibilityChange","countUnread","handleMessageNew","event","_c","_d","newMessageToCurrentChannel","cid","isOwnMessage","user","id","mainChannelUpdated","message","parent_id","show_in_channel","prev","previousUnreadCount","unread_messages","previousLastMessage","getPreviousLastMessage","state","messages","last_read","created_at","Date","on","addEventListener","hasScrolledToBottom","current","off","removeEventListener","newMessage","i","length","msg"],"sources":["C:/Users/Gesti/Desktop/chat_application/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/useMarkRead.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { useEffect, useRef } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, } from '../../../context';\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param unreadCount\n * @param wasChannelMarkedUnread\n */\nexport var useMarkRead = function (_a) {\n    var isMessageListScrolledToBottom = _a.isMessageListScrolledToBottom, messageListIsThread = _a.messageListIsThread, unreadCount = _a.unreadCount, wasMarkedUnread = _a.wasMarkedUnread;\n    var client = useChatContext('useMarkRead').client;\n    var _b = useChannelActionContext('useMarkRead'), markRead = _b.markRead, setChannelUnreadUiState = _b.setChannelUnreadUiState;\n    var channel = useChannelStateContext('useMarkRead').channel;\n    var previousRenderMessageListScrolledToBottom = useRef(isMessageListScrolledToBottom);\n    useEffect(function () {\n        var shouldMarkRead = function (unreadMessages) {\n            return !document.hidden &&\n                !wasMarkedUnread &&\n                !messageListIsThread &&\n                isMessageListScrolledToBottom &&\n                unreadMessages > 0;\n        };\n        var onVisibilityChange = function () {\n            if (shouldMarkRead(channel.countUnread()))\n                markRead();\n        };\n        var handleMessageNew = function (event) {\n            var _a, _b, _c, _d;\n            var newMessageToCurrentChannel = event.cid === channel.cid;\n            var isOwnMessage = ((_a = event.user) === null || _a === void 0 ? void 0 : _a.id) && event.user.id === ((_b = client.user) === null || _b === void 0 ? void 0 : _b.id);\n            var mainChannelUpdated = !((_c = event.message) === null || _c === void 0 ? void 0 : _c.parent_id) || ((_d = event.message) === null || _d === void 0 ? void 0 : _d.show_in_channel);\n            if (isOwnMessage)\n                return;\n            if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n                setChannelUnreadUiState(function (prev) {\n                    var _a, _b;\n                    var previousUnreadCount = (_a = prev === null || prev === void 0 ? void 0 : prev.unread_messages) !== null && _a !== void 0 ? _a : 0;\n                    var previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n                    return __assign(__assign({}, (prev || {})), { last_read: (_b = prev === null || prev === void 0 ? void 0 : prev.last_read) !== null && _b !== void 0 ? _b : (previousUnreadCount === 0 && (previousLastMessage === null || previousLastMessage === void 0 ? void 0 : previousLastMessage.created_at)\n                            ? new Date(previousLastMessage.created_at)\n                            : new Date(0)), unread_messages: previousUnreadCount + 1 });\n                });\n            }\n            else if (newMessageToCurrentChannel &&\n                mainChannelUpdated &&\n                shouldMarkRead(channel.countUnread())) {\n                markRead();\n            }\n        };\n        client.on('message.new', handleMessageNew);\n        document.addEventListener('visibilitychange', onVisibilityChange);\n        var hasScrolledToBottom = previousRenderMessageListScrolledToBottom.current !== isMessageListScrolledToBottom &&\n            isMessageListScrolledToBottom;\n        if (hasScrolledToBottom && shouldMarkRead(channel.countUnread()))\n            markRead();\n        previousRenderMessageListScrolledToBottom.current = isMessageListScrolledToBottom;\n        return function () {\n            client.off('message.new', handleMessageNew);\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n        };\n    }, [\n        channel,\n        client,\n        isMessageListScrolledToBottom,\n        markRead,\n        messageListIsThread,\n        setChannelUnreadUiState,\n        unreadCount,\n        wasMarkedUnread,\n    ]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n    if (!newMessage)\n        return;\n    var previousLastMessage;\n    for (var i = messages.length - 1; i >= 0; i--) {\n        var msg = messages[i];\n        if (!(msg === null || msg === void 0 ? void 0 : msg.id))\n            break;\n        if (msg.id !== newMessage.id) {\n            previousLastMessage = msg;\n            break;\n        }\n    }\n    return previousLastMessage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}