{"ast":null,"code":"import { useCallback, useEffect, useState } from 'react';\n/**\n * Controls the logic when an `UnreadMessagesNotification` component should be shown.\n * In virtualized message list there is no notion of being scrolled below or above `UnreadMessagesSeparator`.\n * Therefore, the `UnreadMessagesNotification` component is rendered based on timestamps.\n * If the there are unread messages in the channel and the `VirtualizedMessageList` renders\n * messages created later than the last read message in the channel, then the\n * `UnreadMessagesNotification` component is rendered. This is an approximate equivalent to being\n * scrolled below the `UnreadMessagesNotification` component.\n * @param lastRead\n * @param showAlways\n * @param unreadCount\n */\nexport var useUnreadMessagesNotificationVirtualized = function (_a) {\n  var lastRead = _a.lastRead,\n    showAlways = _a.showAlways,\n    unreadCount = _a.unreadCount;\n  var _b = useState(false),\n    show = _b[0],\n    setShow = _b[1];\n  var toggleShowUnreadMessagesNotification = useCallback(function (renderedMessages) {\n    if (!unreadCount) return;\n    var firstRenderedMessage = renderedMessages[0];\n    var lastRenderedMessage = renderedMessages.slice(-1)[0];\n    if (!(firstRenderedMessage && lastRenderedMessage)) return;\n    var scrolledBelowSeparator = !!lastRead && new Date(firstRenderedMessage.created_at).getTime() > lastRead.getTime();\n    var scrolledAboveSeparator = !!lastRead && new Date(lastRenderedMessage.created_at).getTime() < lastRead.getTime();\n    setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);\n  }, [lastRead, showAlways, unreadCount]);\n  useEffect(function () {\n    if (!unreadCount) setShow(false);\n  }, [unreadCount]);\n  return {\n    show: show,\n    toggleShowUnreadMessagesNotification: toggleShowUnreadMessagesNotification\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useState","useUnreadMessagesNotificationVirtualized","_a","lastRead","showAlways","unreadCount","_b","show","setShow","toggleShowUnreadMessagesNotification","renderedMessages","firstRenderedMessage","lastRenderedMessage","slice","scrolledBelowSeparator","Date","created_at","getTime","scrolledAboveSeparator"],"sources":["C:/Users/Gesti/Desktop/chat_application/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/VirtualizedMessageList/useUnreadMessagesNotificationVirtualized.js"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\n/**\n * Controls the logic when an `UnreadMessagesNotification` component should be shown.\n * In virtualized message list there is no notion of being scrolled below or above `UnreadMessagesSeparator`.\n * Therefore, the `UnreadMessagesNotification` component is rendered based on timestamps.\n * If the there are unread messages in the channel and the `VirtualizedMessageList` renders\n * messages created later than the last read message in the channel, then the\n * `UnreadMessagesNotification` component is rendered. This is an approximate equivalent to being\n * scrolled below the `UnreadMessagesNotification` component.\n * @param lastRead\n * @param showAlways\n * @param unreadCount\n */\nexport var useUnreadMessagesNotificationVirtualized = function (_a) {\n    var lastRead = _a.lastRead, showAlways = _a.showAlways, unreadCount = _a.unreadCount;\n    var _b = useState(false), show = _b[0], setShow = _b[1];\n    var toggleShowUnreadMessagesNotification = useCallback(function (renderedMessages) {\n        if (!unreadCount)\n            return;\n        var firstRenderedMessage = renderedMessages[0];\n        var lastRenderedMessage = renderedMessages.slice(-1)[0];\n        if (!(firstRenderedMessage && lastRenderedMessage))\n            return;\n        var scrolledBelowSeparator = !!lastRead &&\n            new Date(firstRenderedMessage.created_at).getTime() > lastRead.getTime();\n        var scrolledAboveSeparator = !!lastRead &&\n            new Date(lastRenderedMessage.created_at).getTime() < lastRead.getTime();\n        setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);\n    }, [lastRead, showAlways, unreadCount]);\n    useEffect(function () {\n        if (!unreadCount)\n            setShow(false);\n    }, [unreadCount]);\n    return { show: show, toggleShowUnreadMessagesNotification: toggleShowUnreadMessagesNotification };\n};\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,wCAAwC,GAAG,SAAAA,CAAUC,EAAE,EAAE;EAChE,IAAIC,QAAQ,GAAGD,EAAE,CAACC,QAAQ;IAAEC,UAAU,GAAGF,EAAE,CAACE,UAAU;IAAEC,WAAW,GAAGH,EAAE,CAACG,WAAW;EACpF,IAAIC,EAAE,GAAGN,QAAQ,CAAC,KAAK,CAAC;IAAEO,IAAI,GAAGD,EAAE,CAAC,CAAC,CAAC;IAAEE,OAAO,GAAGF,EAAE,CAAC,CAAC,CAAC;EACvD,IAAIG,oCAAoC,GAAGX,WAAW,CAAC,UAAUY,gBAAgB,EAAE;IAC/E,IAAI,CAACL,WAAW,EACZ;IACJ,IAAIM,oBAAoB,GAAGD,gBAAgB,CAAC,CAAC,CAAC;IAC9C,IAAIE,mBAAmB,GAAGF,gBAAgB,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,IAAI,EAAEF,oBAAoB,IAAIC,mBAAmB,CAAC,EAC9C;IACJ,IAAIE,sBAAsB,GAAG,CAAC,CAACX,QAAQ,IACnC,IAAIY,IAAI,CAACJ,oBAAoB,CAACK,UAAU,CAAC,CAACC,OAAO,CAAC,CAAC,GAAGd,QAAQ,CAACc,OAAO,CAAC,CAAC;IAC5E,IAAIC,sBAAsB,GAAG,CAAC,CAACf,QAAQ,IACnC,IAAIY,IAAI,CAACH,mBAAmB,CAACI,UAAU,CAAC,CAACC,OAAO,CAAC,CAAC,GAAGd,QAAQ,CAACc,OAAO,CAAC,CAAC;IAC3ET,OAAO,CAACJ,UAAU,GAAGU,sBAAsB,IAAII,sBAAsB,GAAGJ,sBAAsB,CAAC;EACnG,CAAC,EAAE,CAACX,QAAQ,EAAEC,UAAU,EAAEC,WAAW,CAAC,CAAC;EACvCN,SAAS,CAAC,YAAY;IAClB,IAAI,CAACM,WAAW,EACZG,OAAO,CAAC,KAAK,CAAC;EACtB,CAAC,EAAE,CAACH,WAAW,CAAC,CAAC;EACjB,OAAO;IAAEE,IAAI,EAAEA,IAAI;IAAEE,oCAAoC,EAAEA;EAAqC,CAAC;AACrG,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}