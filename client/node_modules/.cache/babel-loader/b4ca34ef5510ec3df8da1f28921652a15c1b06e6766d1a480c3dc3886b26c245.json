{"ast":null,"code":"import { __awaiter, __generator, __spreadArray } from \"tslib\";\n/**\n * prevent from duplicate invocation of channel.watch()\n * when events 'notification.message_new' and 'notification.added_to_channel' arrive at the same time\n */\nvar WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL = {};\n/**\n * Calls channel.watch() if it was not already recently called. Waits for watch promise to resolve even if it was invoked previously.\n * @param client\n * @param members\n * @param options\n * @param type\n * @param id\n * @param channel\n */\nexport var getChannel = function (_a) {\n  var channel = _a.channel,\n    client = _a.client,\n    id = _a.id,\n    members = _a.members,\n    options = _a.options,\n    type = _a.type;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var theChannel, originalCid, queryPromise;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (!channel && !type) {\n            throw new Error('Channel or channel type have to be provided to query a channel.');\n          }\n          theChannel = channel || client.channel(type, id, {\n            members: members\n          });\n          originalCid = (theChannel === null || theChannel === void 0 ? void 0 : theChannel.id) ? theChannel.cid : members && members.length ? generateChannelTempCid(theChannel.type, members) : undefined;\n          if (!originalCid) {\n            throw new Error('Channel ID or channel members array have to be provided to query a channel.');\n          }\n          queryPromise = WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n          if (!queryPromise) return [3 /*break*/, 2];\n          return [4 /*yield*/, queryPromise];\n        case 1:\n          _b.sent();\n          return [3 /*break*/, 4];\n        case 2:\n          WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid] = theChannel.watch(options);\n          return [4 /*yield*/, WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid]];\n        case 3:\n          _b.sent();\n          delete WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n          _b.label = 4;\n        case 4:\n          return [2 /*return*/, theChannel];\n      }\n    });\n  });\n};\n// Channels created without ID need to be referenced by an identifier until the back-end generates the final ID.\nvar generateChannelTempCid = function (channelType, members) {\n  if (!members) return;\n  var membersStr = __spreadArray([], members, true).sort().join(',');\n  return \"\".concat(channelType, \":!members-\").concat(membersStr);\n};","map":{"version":3,"names":["__awaiter","__generator","__spreadArray","WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL","getChannel","_a","channel","client","id","members","options","type","theChannel","originalCid","queryPromise","_b","label","Error","cid","length","generateChannelTempCid","undefined","sent","watch","channelType","membersStr","sort","join","concat"],"sources":["C:/Users/Gesti/Desktop/chat_application/client/node_modules/stream-chat-react/dist/utils/getChannel.js"],"sourcesContent":["import { __awaiter, __generator, __spreadArray } from \"tslib\";\n/**\n * prevent from duplicate invocation of channel.watch()\n * when events 'notification.message_new' and 'notification.added_to_channel' arrive at the same time\n */\nvar WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL = {};\n/**\n * Calls channel.watch() if it was not already recently called. Waits for watch promise to resolve even if it was invoked previously.\n * @param client\n * @param members\n * @param options\n * @param type\n * @param id\n * @param channel\n */\nexport var getChannel = function (_a) {\n    var channel = _a.channel, client = _a.client, id = _a.id, members = _a.members, options = _a.options, type = _a.type;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var theChannel, originalCid, queryPromise;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!channel && !type) {\n                        throw new Error('Channel or channel type have to be provided to query a channel.');\n                    }\n                    theChannel = channel || client.channel(type, id, { members: members });\n                    originalCid = (theChannel === null || theChannel === void 0 ? void 0 : theChannel.id)\n                        ? theChannel.cid\n                        : members && members.length\n                            ? generateChannelTempCid(theChannel.type, members)\n                            : undefined;\n                    if (!originalCid) {\n                        throw new Error('Channel ID or channel members array have to be provided to query a channel.');\n                    }\n                    queryPromise = WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n                    if (!queryPromise) return [3 /*break*/, 2];\n                    return [4 /*yield*/, queryPromise];\n                case 1:\n                    _b.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid] = theChannel.watch(options);\n                    return [4 /*yield*/, WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid]];\n                case 3:\n                    _b.sent();\n                    delete WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n                    _b.label = 4;\n                case 4: return [2 /*return*/, theChannel];\n            }\n        });\n    });\n};\n// Channels created without ID need to be referenced by an identifier until the back-end generates the final ID.\nvar generateChannelTempCid = function (channelType, members) {\n    if (!members)\n        return;\n    var membersStr = __spreadArray([], members, true).sort().join(',');\n    return \"\".concat(channelType, \":!members-\").concat(membersStr);\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,WAAW,EAAEC,aAAa,QAAQ,OAAO;AAC7D;AACA;AACA;AACA;AACA,IAAIC,mCAAmC,GAAG,CAAC,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,UAAU,GAAG,SAAAA,CAAUC,EAAE,EAAE;EAClC,IAAIC,OAAO,GAAGD,EAAE,CAACC,OAAO;IAAEC,MAAM,GAAGF,EAAE,CAACE,MAAM;IAAEC,EAAE,GAAGH,EAAE,CAACG,EAAE;IAAEC,OAAO,GAAGJ,EAAE,CAACI,OAAO;IAAEC,OAAO,GAAGL,EAAE,CAACK,OAAO;IAAEC,IAAI,GAAGN,EAAE,CAACM,IAAI;EACpH,OAAOX,SAAS,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;IACjD,IAAIY,UAAU,EAAEC,WAAW,EAAEC,YAAY;IACzC,OAAOb,WAAW,CAAC,IAAI,EAAE,UAAUc,EAAE,EAAE;MACnC,QAAQA,EAAE,CAACC,KAAK;QACZ,KAAK,CAAC;UACF,IAAI,CAACV,OAAO,IAAI,CAACK,IAAI,EAAE;YACnB,MAAM,IAAIM,KAAK,CAAC,iEAAiE,CAAC;UACtF;UACAL,UAAU,GAAGN,OAAO,IAAIC,MAAM,CAACD,OAAO,CAACK,IAAI,EAAEH,EAAE,EAAE;YAAEC,OAAO,EAAEA;UAAQ,CAAC,CAAC;UACtEI,WAAW,GAAG,CAACD,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACJ,EAAE,IAC9EI,UAAU,CAACM,GAAG,GACdT,OAAO,IAAIA,OAAO,CAACU,MAAM,GACrBC,sBAAsB,CAACR,UAAU,CAACD,IAAI,EAAEF,OAAO,CAAC,GAChDY,SAAS;UACnB,IAAI,CAACR,WAAW,EAAE;YACd,MAAM,IAAII,KAAK,CAAC,6EAA6E,CAAC;UAClG;UACAH,YAAY,GAAGX,mCAAmC,CAACU,WAAW,CAAC;UAC/D,IAAI,CAACC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;UAC1C,OAAO,CAAC,CAAC,CAAC,WAAWA,YAAY,CAAC;QACtC,KAAK,CAAC;UACFC,EAAE,CAACO,IAAI,CAAC,CAAC;UACT,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QAC3B,KAAK,CAAC;UACFnB,mCAAmC,CAACU,WAAW,CAAC,GAAGD,UAAU,CAACW,KAAK,CAACb,OAAO,CAAC;UAC5E,OAAO,CAAC,CAAC,CAAC,WAAWP,mCAAmC,CAACU,WAAW,CAAC,CAAC;QAC1E,KAAK,CAAC;UACFE,EAAE,CAACO,IAAI,CAAC,CAAC;UACT,OAAOnB,mCAAmC,CAACU,WAAW,CAAC;UACvDE,EAAE,CAACC,KAAK,GAAG,CAAC;QAChB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,YAAYJ,UAAU,CAAC;MAC7C;IACJ,CAAC,CAAC;EACN,CAAC,CAAC;AACN,CAAC;AACD;AACA,IAAIQ,sBAAsB,GAAG,SAAAA,CAAUI,WAAW,EAAEf,OAAO,EAAE;EACzD,IAAI,CAACA,OAAO,EACR;EACJ,IAAIgB,UAAU,GAAGvB,aAAa,CAAC,EAAE,EAAEO,OAAO,EAAE,IAAI,CAAC,CAACiB,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAClE,OAAO,EAAE,CAACC,MAAM,CAACJ,WAAW,EAAE,YAAY,CAAC,CAACI,MAAM,CAACH,UAAU,CAAC;AAClE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}